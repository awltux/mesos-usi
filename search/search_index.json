{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Unified Scheduler Interface"},{"location":"/index.html#unified-scheduler-interface","text":"This repository is currently a work-in-progress.\nHow to run:\n$ gradle :hello-world:run\nHow to test:\n$ gradle test","title":"Unified Scheduler Interface"},{"location":"/getting-started.html","text":"","title":"Getting Started"},{"location":"/getting-started.html#getting-started","text":"","title":"Getting Started"},{"location":"/contributing/index.html","text":"","title":"Contributors Guide"},{"location":"/contributing/index.html#contributors-guide","text":"Make contributions with GitHub pull requests.","title":"Contributors Guide"},{"location":"/contributing/index.html#bugs-feature-requests","text":"Think you’ve found a bug? Want to see a new feature? Please open a case in our issue management tool, JIRA: * Login to the DC/OS USI Public JIRA. You will need a Github or Google account to use this service. * Navigate to the DC/OS OSS USI project. * Click Create Issue - Please provide as much information as possible about the issue type and how to reproduce it. * Github Issues for this project have been disabled. * Bug reports in JIRA for the Mesosphere USI project are public.\nIf you would like to propose a new feature or a significant change, first open an issue (instructions above) to discuss it. Project shepherds will provide feedback on the proposed change in terms of feasibility, design, and implementation guidance. While all proposals are welcome, those that conflict with our roadmap or design principles may not be accepted.","title":"Bugs / Feature Requests"},{"location":"/contributing/index.html#creating-pull-requests","text":"Create pull requests against the master branch. Be sure to include unit tests and integration tests, as well as updates to the documentation, default scheduler, and reference framework if necessary.\nSee the (testing documentation)[TESTING.md] for instructions on running static code checks and system integration tests.\nSimple pull requests (e.g., to fix documentation or comments) are welcome without an issue, but any substantial changes require an issue and discussion ahead of time.","title":"Creating Pull Requests"},{"location":"/contributing/index.html#merge-approvals","text":"Pull requests are reviewed and tested prior to merging. Often shepherds will ask contributors to make changes based on our style guidelines, design principles, or project goals. An initial response is typically provided in less than one week.","title":"Merge Approvals"},{"location":"/contributing/index.html#communication","text":"Most communication is done primarily over Slack. Join us via http://chat.dcos.io in the #usi and #usi-dev channels, for users and developers respectively.\nTo build a healthy, respectful community, we follow Github’s community guidelines.","title":"Communication"},{"location":"/contributing/index.html#licensing","text":"Mesosphere USI is licensed under the Apache License, Version 2.0. Any code you submit must be under that license.\nFor significant changes, we may ask you to sign a Contributor License Agreement.","title":"Licensing"},{"location":"/contributing/code-culture.html","text":"","title":"Code Culture"},{"location":"/contributing/code-culture.html#code-culture","text":"","title":"Code Culture"},{"location":"/contributing/code-culture.html#overview","text":"The code culture is a set of defaults ascribed to by the Orchestration developer team. Since writing software is an optimization problem, we guide our design decisions with defaults, not rules. Deviations from our defaults require justification.\nOur defaults are:\nCode is legible on GitHub Immutability over mutability No smelly code Fail loud and proud Let it crash Don’t panic Structured logging","title":"Overview"},{"location":"/contributing/code-culture.html#code-is-legible-on-github","text":"This default speaks to the desire to write code that can be understood without needing an IDE. USI is written in Scala, so our defaults are specific as such.","title":"Code is Legible on GitHub"},{"location":"/contributing/code-culture.html#on-implicits","text":"Implicits are an important feature in Scala and are critical for the implementation of type-classes and DSLs.\nPrefer:\nExplicit conversion over implicit Explicit passing over implicit\nFor our case, if implicits don’t help improve the design of code, we don’t use them. We avoid implicit conversions. We also avoid multi-priority implicits. When type classes help improve the design of code, we use implicits for type classes (IE serialization logic).\nWe prefer implicits to be used for contextual values such as execution contexts or the actor system. However, we prefer to be conservative, and pass the value explicitly for things like validators, authenticators, and normalizers.","title":"On Implicits"},{"location":"/contributing/code-culture.html#on-type-inference","text":"If you are writing some function chain that has multiple levels of inferred function parameter types, we prefer to specify the parameter types.\nPrefer:\ngroups.map { group: Group =>\n  group.apps\n    .groupBy(_.container.image)\n    .map { case (image: String, apps: Seq[App]) =>\n      image -> apps.length\n    }\n  }\nOver:\ngroups.map { group =>\n  group.apps.groupBy(_.container.image).map { case(k, v) =>\n    k -> v.length\n  }\n}","title":"On Type Inference"},{"location":"/contributing/code-culture.html#on-playing-code-golf","text":"Code golf is a game in which you implement some program in as few characters as possible.\nWe prefer not to play this game when working on USI. Instead, we focus on removing noise (boilerplate), while preserving valuable signal pertaining to the problem at hand.","title":"On Playing Code Golf"},{"location":"/contributing/code-culture.html#on-imports","text":"We prefer, almost always, that imports go at the top of the file. Additionally, prefer explicit imports over wildcard imports.\nPrefer:\nimport org.company.{\n  Stringifier,\n  Demuxer\n}\nOver:\nimport org.company._","title":"On Imports"},{"location":"/contributing/code-culture.html#immutability-over-mutability","text":"Functional programming is what follows when you don’t mutate state. We prefer it, except in performance critical parts of our code.\nWe have a strong preference to encapsulate mutable state. References to data crossing the boundary of some module should be immutable.","title":"Immutability Over Mutability"},{"location":"/contributing/code-culture.html#no-smelly-code","text":"We pay attention to code smells and strive to write well encapsulated code.\nA method should not receive more data than it needs to do its job. Changing some behavior should not result in “shotgun surgery”","title":"No Smelly Code"},{"location":"/contributing/code-culture.html#on-todos","text":"TODOs are as liberally used as they are ignored. TODOs should be only used for one of two reasons:\nThings you plan to do before merging Things that are definitely planned in the near future (with a high-priority JIRA)\nInstead of a TODO, prefer:\nCode that fails (e.g. throw a not-implemented exception) A comment describing the pitfalls of the implementation (e.g. this code does not perform very well, or, this code is prone to bugs from possible rounding errors)","title":"On TODOs"},{"location":"/contributing/code-culture.html#fail-loud-and-proud","text":"It is better to do nothing, than to do the wrong thing.\nOne of my favorite non-examples of this is found in PHP 5:\n$ echo '<? print(strftime(\"%Y-%m-%d\",strtotime(\"lol\"))) ?>' | php\n1970-01-01\nAnother non-example is found in Marathon’s history. At one point in time, the storage layer would swallow the exception and return None if it could not deserialize some entity successfully, and this led to data loss.\nWe are strict in what we accept, and in what we emit. If input is not what we expect, don’t be fancy.\nFail loudly. Fail proudly.","title":"Fail Loud and Proud"},{"location":"/contributing/code-culture.html#let-it-crash","text":"We prefer to focus on state recovery, and not graceful tear down. We’d prefer to just crash and restart, rather than implement many complex error recovery handlers.","title":"Let it Crash"},{"location":"/contributing/code-culture.html#dont-panic","text":"We prefer to that Exceptions are thrown only when something goes unexpectedly wrong outside of domain of the library.\nFor example:\nA validation function should return validation errors, not throw them. A storage module will throw an exception if a connection is unavailable.","title":"Don’t Panic"},{"location":"/contributing/code-culture.html#structured-logging","text":"Debugging distributed system is hard. To make this at least a bit easier we favor log messages including logging context (using structured logging). Core USI is providing all necessary tooling for framework developer to log in structured way.\nFor introduction to structured logging read this article.\nAll relevant ids should be part of the logging message e.g.:\npod ID (“podId”) mesos task ID (“taskId”) mesos offer ID (“offerId”)\nIt’s important to keep the naming of keys consistent so that one can use them for log pre-selection.\nEven though structured logging is strongly recommended to every framework developer, including context into the final log message is always optional. We should aim for keeping our messages meaningful even without the context provided (it’s ok to duplicate e.g. podId both in messaage and context).\nExample of good framework log messages (a little bit simplified) can look like example below:\n{\n  \"time\": \"1.1.1970\",\n  \"level\": \"INFO\",\n  \"podId\": \"my-pod\",\n  \"taskId\": \"mesos-task-my-pod-1\",\n  \"message\": \"Task $taskId of Pod $podId was killed\"\n}","title":"Structured logging"},{"location":"/contributing/code-culture.html#testing","text":"Tests are executable documentation and should be written, read and maintained as such. A test tells its reader a short story about how some part of the system should behave given a certain input. Hundreds of excellent books and articles are dedicated to writing proper tests, so we’ll try to avoid repeating them here, however:\nChoose the lightest testing mechanism that suits the need; if something can be tested well at a unit level, then test there first. IE: An integration test might check that a validation error is properly returned via the API, but a unit test should check the 20 different ways a validation fails. Avoid mocks/stubbing. Mocks are often a code smell that happens when effects are coupled with business logic, and the tests often look too much like the implementation. If we separate our effects then we don’t need mocks. Preference for fake implementations of interfaces (IE MockMesos flow) over “method X should be invoked once with param Y and return Z”.","title":"Testing"},{"location":"/contributing/code-culture.html#on-libraries-and-styles","text":"We heavily utilize ScalaTest as our primary test library. All tests should implement the UnitTest class in test-utils, which uses WordSpec.\n// The number of nested levels is dependent on your test case.\n  // For most tests one or two are levels are enough.\n  // Describe a scope for a subject, in this case: \"An empty Set\"\n  \"An empty Set\" should { // All tests within these curly braces are about \"A Set\"\n\n        \"have size 0\" in {    // Here, 'it' refers to \"A Set (when empty)\". The full name\n          Set.empty.size shouldBe 0 // of this test is: \"A Set (when empty) should have size 0\n      }\n      ...\ncombined with Given, When, And Then and scala matchers:\n\"A mutable Set\" should\n\n    \"allow an element to be added\" in {\n      Given(\"an empty mutable Set\")\n      val set = mutable.Set.empty[String]\n\n      When(\"an element is added\")\n      set += \"clarity\"\n\n      Then(\"the Set should have size 1\")\n      set.size shouldBe 1\n\n      And(\"the Set should contain the added element\")\n      set should contain theSameElementsAs Set(\"clarity\")\n    }\n  }\nwhich give us an opportunity to write a test as a short story documenting part of the system behaviour.","title":"On Libraries and Styles"},{"location":"/contributing/code-culture.html#on-testing-granularity","text":"In USI we define following granularity levels:\nUnit tests: the lowest test level possible. Unit test are cheap, can be run fast and give the developer an immediate feedback on when something is obviously broken Integration tests: an integration test starts a minimal Mesos cluster consisting of Mesos master, Mesos agent, in-memory Zookeeper server and a framework. These are more expensive tests that typically require more resources and time to run. Tests that require back and forth communication with Mesos are best placed here because we don’t want to mock Mesos responses. System integraiton test: here we start a full-blown DC/OS cluster testing all aspects of framework interacting with the DC/OS ecosystem. These are the most expensive tests (in terms of time and money) that would typically reqire a DC/OS cluster running on e.g. AWS utilizing multiple EC2 nodes, volumes, ELB etc. A system integration test would typically cover some coarse-grained USI feature or a feature that relies on other DC/OS components like the secret store.\nAs a rule of thumb, a broken behavior should fail at the lowest possible level. Most features will be covered on more than one level but the coverage is different. Let’s consider support for Mesos fetcher as an example. In preparation to run a task, the Mesos fetcher downloads resources into the task’s sandbox directory. So how do the tests look like?\nUnit test: makes sure that given a PodSpec with a defined fetch URI it is converted to a Mesos protobuf message, where correspoding URI fields are initialized properly Integration test: makes sure that when a task from a PodSpec is started, the fetched artifact is actually part of its sandbox System integration test: this is a tricky one; do we need full DC/OS cluster to test this? How is this different from the integration test from the fetchers perspective? The simple answer is that it’s not, and an integration test might be sufficient enough.\nHowever consider the following aspects (which are all taken from prior experience building Mesos frameworks):\nWhile an integration test usually starts some stable Mesos version on which USI officially depends, DC/OS frequently integrates the latest Mesos changes into its master branch. Testing a framework against the latest DC/OS master might expose a bug sooner rather than later. An integration test runs against a local Mesos cluster where communication is typically fast and reliable. A system integration test runs against a cluster somewhere in the cloud, and has a different communications profile. In the past, we’ve seen bugs that would only manifest themselves in the latter case, but not in the former. Admittedly, it seems unlikely that such a bug is triggered in the Mesos fetcher; however, we’ve seen unlikely things happen before. Even a simple request to the framework running on a DC/OS cluster touches many components on its way (e.g. ELB, Admin Router, Monitoring service which themselves rely on other components, such as Admin Router relying on CockroachDB), so there is always potential for things to go wrong.\nIt makes sense to have a system integration test for every user-facing coarse-grained API feature, including the example above.","title":"On Testing Granularity"},{"location":"/examples/index.html","text":"","title":"Examples"},{"location":"/examples/index.html#examples","text":"","title":"Examples"},{"location":"/examples/keep-alive-framework.html","text":"","title":"Keep-Alive Example Framework"},{"location":"/examples/keep-alive-framework.html#keep-alive-example-framework","text":"Run the keep-alive example framework that: - uses simplified Scheduler interface - starts configurable amount of echo \"Hello, world\" && sleep 20 tasks (default 100) - keeps restarting the task if it finishes","title":"Keep-Alive Example Framework"},{"location":"/examples/keep-alive-framework.html#deployment-on-dc-os-enterprise","text":"Launch strict cluster and setup the DC/OS CLI. Create key pair: dcos security org service-accounts keypair usi.private.pem usi.pub.pem Create user usi: dcos security org service-accounts create -p usi.pub.pem -d \"For testing USI on strict\" usi Store private key as secret: dcos security secrets create -f ./usi.private.pem usi/private_key Grant usi access: dcos security org users grant usi dcos:mesos:master:task:user:nobody create dcos security org users grant usi dcos:mesos:master:framework:role:usi read dcos security org users grant usi dcos:mesos:master:framework:role:usi create Deploy the framework: dcos marathon app add keep-alive-framework-app.json","title":"Deployment on DC/OS Enterprise"}]}